
# Use-cases:

## A
Sender/data provider submits encrypted data files and id-lists to intermediate (single transaction with multiple inputs).
ID-management performs record linkage and pseudonymisation on id-list. Outputs global pseudonyms for Data-warehouse. Outputs local pseudonyms for sender.
Data-warehouse uses data files and global-pseudonyms to process/import the data. Reports success/error status and log file to sender.
Sender retrieves local pseudonyms (optional)
(multiple transaction with different data sources may be processed simultaneously)

## B 
Sender can instruct data-warehouse to drop data from previously successful transaction.

## C
Data-warehouse sends info via intermediate to data provider containing feedback to some  global pseudonyms. E.g. invalid data. E.g. biomaterial transfer.
ID-management translates global pseudonyms to id-list or local pseudonyms.
Data provider receives feedback. Reports status accept/reject/success/etc.

## D
Sender/data provider submits id-list to intermediate.
ID-management performs record linkage and pseudonymisation on id-list. Outputs local pseudonyms for sender.
Sender retrieves local pseudonyms.




# Architecture options

Infrastructure contains one or more sender. Each sender always talks to a single intermediate.
Infrastructure contains one or more receivers. Each receiver always talks to a single intermediate.
Intermediate manages transactions between senders and receivers.
Transactions are independent from each other. They do not interact with one another. Except optionally via topic-id.


## Option 1 Server cascade (not implemented)
Intermediate can perform processes on a transaction and upon completion will forward the transaction to other intermediates or receivers.
Receiver is like an intermediate, but does not forward the transaction to others.
Intermediate and receiver will provide the API endpoints described by the following description

Client -> Intermediate operations are the same as Intermediate -> Receiver operations - Except that intermediate will act in the name/ on behalf of a client.
This will allow a chain or cascade of multiple intermediate and receivers. Intermediate and receivers both need to allow incoming connections.
 
## Option 2 Server broker (preferred)

Client -> Intermediate operations are similar to Receiver -> Intermediate operations. 
Intermediate is central component allowing incoming connections from both client and receivers.

Pseudonymisation process will take sender input and may produce output for recipient.
Data warehouse will take sender input and pseudonymisation output and produce status feedback.

Sender will use the same API as receiver.

# Architecture draft

```
Client := Sender|Receiver
Server := Intermediate
acl := 'access control list'
```

## Transaction
Transaction can have multiple input files defined by the client.

Transaction can have multiple output files. The output files are typically logfiles generated by processes of receiving clients.
```
Client perspective: client.created, client.submitted, 
planned(process): The transaction will probably be processed by the specified (server,process) but was not yet submitted/queued to the specific process. E.g. the process does not know of this transaction. 
queued(process): The transaction was submitted to the specified (server,process) and is waiting for execution.
processing(process, progress): The transaction is currently being processed.
interaction(process): The transaction is waiting for external user interaction at the specified (server, process)
failed(process): The process failed. Error log can be retrieved.
rejected(process): The transaction was rejected e.g. by a manual review or interaction processes.
completed(process)
```

## Client

### Configuration
- Intermediate server+port
- Client authentication info

###  List transactions
`client-id` parameter is always determined by provided authentication information at intermediate.

Client can retrieve a list of his transactions. The list may contain the transaction status.
`list-outbound-transactions(client-id)` -> list of transaction-metadata or list of transaction-id
returns a list of transaction created by the specified client-id

`list-outbound-transactions(domain-id)` (optional) -> list of transaction-metadata or list of transaction-id
returns a list of transactions created by the specified domain-id

`list-inbound-transactions(domain-id)`
return list of transactions which have input files or output files targeted at the specified domain.

### Create transaction
Client (sender or receiver) can create a new transaction. The newly created transaction is in status "Created"/draft.
`create-transaction(client-id, domain-id, topic-id) -> transaction-id`

Multiple transaction can use the same topic-id, but only one should be in state submitted. The others need to be draft or rollback.

### Read transaction metadata
Client can read details about the transactions in outbound or inbound list.
Outbound list contains all transactions created with the same domain as client.
Inbound list contains all transactions which have input/output with ACL containing the same domain as client.

`read-transaction(transaction-id) -> transaction-metadata`
Transaction metadata contains the following information
- transaction-id
- client-id + client-domain (transaction creator)
- topic-id (user defined string/tag)
- created-timestamp
- submitted-timestamp
- rollback-timestamp
- list of input files
    - file-name
    - media-type
    - acl: specific recipient domains
    - optional hash
- list of processes
    - process-id
    - client-id + client-domain (process creator)
    - status
    - list of output files
        - file-name
        - media-type
        - acl: specific recipient domains (e.g. transaction creater domain for feedback)
        - optional hash

### Upload transaction content/file
`put-file(transaction-id, client-id, process-id, file-name, media-type, acl-domains) -> void`
Attaches a file to the transaction. 
If the transaction was created by this client, the file is appended to input files. Process-id must be null.
If the transaction was created by a different client, then a process id must be specified. File is appended to process files.

### Cancel/rollback transaction.
At any time, the client can invoke the "cancel/rollback" operation on a submitted transaction.
For a canceled transaction, the input files and output files can be deleted.
`rollback-transaction(client-id, transaction-id) -> void`

### Submit transaction
Once all parts of the transaction are uploaded, the sender will invoke the "submit" operation on the transaction.
From this point on, the transaction may be processed by the intermediate and is made available to any recipients.
This operation may be removed and functionality implemented by `update-status(submitted)` when called by transaction-creator.

### Update process status
`update-status(transaction-id, client-id, process-id, status-code) -> void`
Client can update the process status for inbound transactions. Usually used by receivers

### Optional Notifications: Client is able to be notified about any transactions changes and progress.

### Advertise processing capabilities
`update-capabilities(client-id, capability-metadata)`
Publishes client processing capabilities. E.g.
```
<capabilities>
 <!-- ID management -->
 <process id="generate-global-pseudonyms">
  <requires>
   <file id="idat.txt"/>
  </requires>
  <provides>
    <file id="out.txt">
     <acl-domain id="dwh"/>
    </file>
  </provides>
 </process>
 <process id="generate-local-pseudonyms"> 
  <requires>
   <file id="idat.txt"/>
  </requires>
  <provides>
    <file id="out.txt">
     <acl-source/> <!-- default acl behaviour -->
    </file>
    <log/>
  </provides>
 </process>
</capabilities>

<capabilities>
 <!-- Data warehouse -->
 <process id="replace-source-data">
  <dependencies>
   <file id="data.xml" />
   <file id="out.txt" domain="idm" />
  </dependencies>
  <provides>
    <log/>
  </provides>
 </process>
</capabilities>

```


## Intermediate

### Configuration
- map of valid client-ids assigned to client-domains + authentication info

Intermediate also needs to know minimal metadata about the recipients processes. E.g. published by each recipient upon startup.


### Option 1: Intermediate does not have own processes (preferred)
E.g. one client performs pseudonymisation and generates pseudonyms. Another client (data warehouse) will use the pseudonyms and imports data. 
This will also require that some clients do not see specific files e.g. shading input/output using acl or using asymmetric encryption.

### Option 2: Intermediate can run own proceses (not implemented)


